"""
Modern Desktop Wallpaper Manager GUI Application - Web-Inspired Design
Features: Large preview area, compact sidebar controls, countdown timer, auto-fetch
"""

import os
import sys
import json
import platform
import subprocess
import threading
import time
from pathlib import Path
from datetime import datetime
from urllib.parse import urlparse
import tkinter as tk
from tkinter import ttk, filedialog, messagebox
from PIL import Image, ImageTk
import requests


class WallpaperManagerGUI:
    """Main GUI application for wallpaper management with web-inspired design."""
    
    def __init__(self, root):
        """Initialize the wallpaper manager GUI."""
        self.root = root
        self.root.title("Wallpaper Manager")
        self.root.geometry("1000x700")
        self.root.minsize(800, 600)
        self.root.resizable(True, True)
        
        # Dark theme color system (per design spec)
        self.colors = {
            # Backgrounds
            'hero_bg': '#0a0e13',
            'bg_primary': '#0f1419',
            'bg_secondary': '#1a1f26',
            'bg_tertiary': '#242b35',
            'bg_hover': '#2d3748',
            
            # Accents
            'accent_blue': '#3b82f6',
            'accent_purple': '#8b5cf6',
            'accent_cyan': '#06b6d4',
            'success_green': '#10b981',
            'warning_yellow': '#f59e0b',
            'danger_red': '#ef4444',
            
            # Text
            'text_primary': '#f9fafb',
            'text_secondary': '#9ca3af',
            'text_muted': '#6b7280',
            
            # Borders
            'border': '#374151',
            'border_light': '#4b5563'
        }

        self.fonts = {
            'logo': ('Poppins', 28, 'bold'),
            'hero_title': ('Segoe UI', 18, 'normal'),
            'heading': ('Segoe UI', 14, 'bold'),
            'subheading': ('Segoe UI', 12, 'bold'),
            'body': ('Segoe UI', 10, 'normal'),
            'button': ('Segoe UI', 10, 'bold'),
            'small': ('Segoe UI', 8, 'normal'),
            'quote': ('Georgia', 11, 'italic')
        }
        
        # Configure root background
        self.root.configure(bg=self.colors['bg_primary'])
        
        # Setup data directory
        self.data_dir = Path.home() / ".paprwall"
        self.data_dir.mkdir(parents=True, exist_ok=True)
        self.history_file = self.data_dir / "history.json"
        self.wallpapers_dir = self.data_dir / "wallpapers"
        self.wallpapers_dir.mkdir(exist_ok=True)
        
        # Load history
        self.history = self.load_history()
        
        # Track current preview
        self.preview_image_path = None
        self.preview_photo = None
        
        # Timer state for auto-rotation
        self.auto_rotate_enabled = False
        self.rotation_interval_minutes = 60  # Default 60 minutes
        self.time_remaining_seconds = 0
        self.timer_thread = None
        self.stop_timer_flag = False
        
        # Favorites
        self.favorites = self.load_favorites()
        
        # Random resolutions
        self.resolutions = [
            "1920x1080", "2560x1440", "3840x2160",
            "1366x768", "1600x900", "1280x720"
        ]
        
        # Wallpaper types
        self.wallpaper_types = [
            ('üåø Nature', 'nature'),
            ('üé® Abstract', 'abstract'),
            ('‚¨ú Minimal', 'minimal'),
            ('üåë Dark', 'dark'),
            ('üåà Gradient', 'gradient'),
            ('üöÄ Space', 'space'),
            ('üåä Ocean', 'ocean'),
            ('‚õ∞Ô∏è Mountain', 'mountain'),
            ('üèôÔ∏è City', 'city'),
            ('üåÖ Sunset', 'sunset')
        ]
        self.selected_type = tk.StringVar(value='nature')
        
        # Setup UI
        self.setup_ui()
        
        # Load current wallpaper
        self.refresh_display()
        
        # Auto-fetch wallpaper on launch
        self.root.after(500, self.auto_fetch_on_launch)
    
    def setup_ui(self):
        """Setup the user interface with hero section layout."""
        # Main container
        main_container = tk.Frame(self.root, bg=self.colors['bg_primary'])
        main_container.pack(fill=tk.BOTH, expand=True)
        
        # === TOP NAVBAR ===
        navbar = tk.Frame(main_frame, bg=self.colors['sidebar'], height=60)
        navbar.pack(side=tk.TOP, fill=tk.X)
        navbar.pack_propagate(False)
        
        # App title
        title_frame = tk.Frame(navbar, bg=self.colors['sidebar'])
        title_frame.pack(side=tk.LEFT, padx=20, pady=15)
        
        tk.Label(
            title_frame,
            text="üñºÔ∏è",
            font=("Segoe UI", 20),
            bg=self.colors['sidebar']
        ).pack(side=tk.LEFT)
        
        tk.Label(
            title_frame,
            text="Wallpaper Manager",
            font=("Segoe UI", 16, "bold"),
            bg=self.colors['sidebar'],
            fg=self.colors['text']
        ).pack(side=tk.LEFT, padx=(10, 0))
        
        # Quick actions in navbar
        quick_actions = tk.Frame(navbar, bg=self.colors['sidebar'])
        quick_actions.pack(side=tk.RIGHT, padx=20)
        
        # Random wallpaper button
        tk.Button(
            quick_actions,
            text="üé≤ Random",
            command=self.fetch_random_wallpaper,
            bg=self.colors['accent'],
            fg='white',
            font=("Segoe UI", 9, "bold"),
            relief=tk.FLAT,
            cursor="hand2",
            padx=12,
            pady=5
        ).pack(side=tk.LEFT, padx=5)
        
        # Open wallpapers folder button
        tk.Button(
            quick_actions,
            text="üìÅ Folder",
            command=self.open_wallpapers_folder,
            bg='#6c757d',
            fg='white',
            font=("Segoe UI", 9, "bold"),
            relief=tk.FLAT,
            cursor="hand2",
            padx=12,
            pady=5
        ).pack(side=tk.LEFT, padx=5)
        
        # Status in navbar
        self.status_label = tk.Label(
            navbar,
            text="‚óè Ready",
            font=("Segoe UI", 10),
            bg=self.colors['sidebar'],
            fg='#28a745'
        )
        self.status_label.pack(side=tk.RIGHT, padx=20)
        
        # === CONTENT AREA ===
        content = tk.Frame(main_frame, bg=self.colors['bg'])
        content.pack(side=tk.TOP, fill=tk.BOTH, expand=True)
        
        # === RIGHT SIDEBAR (Fixed width) ===
        sidebar = tk.Frame(content, bg=self.colors['sidebar'], width=360)
        sidebar.pack(side=tk.RIGHT, fill=tk.Y, padx=(5, 5), pady=5)
        sidebar.pack_propagate(False)
        
        # Sidebar scrollable content
        sidebar_canvas = tk.Canvas(sidebar, bg=self.colors['sidebar'], highlightthickness=0)
        sidebar_scrollbar = ttk.Scrollbar(sidebar, orient=tk.VERTICAL, command=sidebar_canvas.yview)
        sidebar_content = tk.Frame(sidebar_canvas, bg=self.colors['sidebar'])
        
        sidebar_content.bind(
            "<Configure>",
            lambda e: sidebar_canvas.configure(scrollregion=sidebar_canvas.bbox("all"))
        )
        
        sidebar_canvas.create_window((0, 0), window=sidebar_content, anchor=tk.NW)
        sidebar_canvas.configure(yscrollcommand=sidebar_scrollbar.set)
        
        sidebar_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        sidebar_canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        
        # === SIDEBAR SECTIONS ===
        
        # Source section
        self.create_section_header(sidebar_content, "üåê Image Source")
        
        source_frame = tk.Frame(sidebar_content, bg=self.colors['sidebar'])
        source_frame.pack(fill=tk.X, padx=20, pady=(0, 20))
        
        # Resolution selector
        tk.Label(
            source_frame,
            text="Resolution",
            font=("Segoe UI", 9, "bold"),
            bg=self.colors['sidebar'],
            fg=self.colors['text']
        ).pack(anchor=tk.W, pady=(0, 3))
        
        self.resolution_var = tk.StringVar(value="1920x1080")
        resolution_dropdown = ttk.Combobox(
            source_frame,
            textvariable=self.resolution_var,
            values=self.resolutions,
            state="readonly",
            width=15,
            font=("Segoe UI", 9)
        )
        resolution_dropdown.pack(fill=tk.X, pady=(0, 10))
        resolution_dropdown.bind("<<ComboboxSelected>>", self.update_url_with_resolution)
        
        # URL input
        tk.Label(
            source_frame,
            text="URL",
            font=("Segoe UI", 9, "bold"),
            bg=self.colors['sidebar'],
            fg=self.colors['text']
        ).pack(anchor=tk.W, pady=(0, 3))
        
        self.url_entry = tk.Entry(
            source_frame,
            font=("Segoe UI", 9),
            relief=tk.SOLID,
            borderwidth=1,
            bg='white'
        )
        self.url_entry.pack(fill=tk.X, pady=(0, 6))
        self.url_entry.insert(0, "https://picsum.photos/1920/1080")
        self.url_entry.bind('<Return>', lambda e: self.fetch_from_url())
        
        # Buttons row
        btn_row = tk.Frame(source_frame, bg=self.colors['sidebar'])
        btn_row.pack(fill=tk.X, pady=(0, 8))
        
        self.fetch_btn = tk.Button(
            btn_row,
            text="Fetch",
            command=self.fetch_from_url,
            bg=self.colors['accent'],
            fg='white',
            font=("Segoe UI", 9, "bold"),
            relief=tk.FLAT,
            cursor="hand2",
            padx=10,
            pady=6
        )
        self.fetch_btn.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(0, 3))
        
        # Auto Fetch button
        self.auto_fetch_btn = tk.Button(
            btn_row,
            text="üîÑ Auto",
            command=self.auto_fetch_and_set,
            bg='#28a745',
            fg='white',
            font=("Segoe UI", 9, "bold"),
            relief=tk.FLAT,
            cursor="hand2",
            padx=10,
            pady=6
        )
        self.auto_fetch_btn.pack(side=tk.LEFT, fill=tk.X, expand=True)
        
        # Divider
        tk.Frame(source_frame, bg=self.colors['border'], height=1).pack(fill=tk.X, pady=10)
        
        # Local file
        tk.Label(
            source_frame,
            text="Local File",
            font=("Segoe UI", 9, "bold"),
            bg=self.colors['sidebar'],
            fg=self.colors['text']
        ).pack(anchor=tk.W, pady=(0, 3))
        
        self.file_entry = tk.Entry(
            source_frame,
            font=("Segoe UI", 8),
            relief=tk.SOLID,
            borderwidth=1,
            bg='white'
        )
        self.file_entry.pack(fill=tk.X, pady=(0, 6))
        
        tk.Button(
            source_frame,
            text="üìÅ Browse",
            command=self.browse_file,
            bg='white',
            fg=self.colors['text'],
            font=("Segoe UI", 9),
            relief=tk.SOLID,
            borderwidth=1,
            cursor="hand2",
            padx=12,
            pady=5
        ).pack(fill=tk.X)
        
        # Preview Info section
        self.create_section_header(sidebar_content, "‚ÑπÔ∏è Preview Info")
        
        info_frame = tk.Frame(sidebar_content, bg=self.colors['sidebar'])
        info_frame.pack(fill=tk.X, padx=20, pady=(0, 10))
        
        self.preview_info_text = tk.Text(
            info_frame,
            height=2,
            font=("Segoe UI", 8),
            relief=tk.SOLID,
            borderwidth=1,
            bg='#f8f9fa',
            wrap=tk.WORD,
            padx=6,
            pady=6
        )
        self.preview_info_text.pack(fill=tk.X)
        self.preview_info_text.insert(1.0, "Loading...")
        self.preview_info_text.config(state=tk.DISABLED)
        
        # Progress bar
        self.progress = ttk.Progressbar(
            info_frame,
            mode='indeterminate',
            length=200
        )
        
        # Action buttons
        action_frame = tk.Frame(sidebar_content, bg=self.colors['sidebar'])
        action_frame.pack(fill=tk.X, padx=20, pady=(0, 15))
        
        self.set_button = tk.Button(
            action_frame,
            text="‚úì Set Wallpaper",
            command=self.set_wallpaper,
            state=tk.DISABLED,
            bg='#28a745',
            fg='white',
            font=("Segoe UI", 10, "bold"),
            relief=tk.FLAT,
            cursor="hand2",
            padx=12,
            pady=8
        )
        self.set_button.pack(fill=tk.X, pady=(0, 4))
        
        # Favorite button
        self.favorite_button = tk.Button(
            action_frame,
            text="‚≠ê Favorite",
            command=self.add_to_favorites,
            state=tk.DISABLED,
            bg='#ffc107',
            fg='white',
            font=("Segoe UI", 9, "bold"),
            relief=tk.FLAT,
            cursor="hand2",
            padx=12,
            pady=6
        )
        self.favorite_button.pack(fill=tk.X)
        
        # Auto-Rotation section
        self.create_section_header(sidebar_content, "‚è±Ô∏è Auto-Rotation")
        
        rotation_frame = tk.Frame(sidebar_content, bg=self.colors['sidebar'])
        rotation_frame.pack(fill=tk.X, padx=20, pady=(0, 15))
        
        # Timer display
        timer_display = tk.Frame(rotation_frame, bg='#f8f9fa', relief=tk.SOLID, borderwidth=1)
        timer_display.pack(fill=tk.X, pady=(0, 6))
        
        tk.Label(
            timer_display,
            text="Next:",
            font=("Segoe UI", 8),
            bg='#f8f9fa',
            fg=self.colors['text']
        ).pack(side=tk.LEFT, padx=8, pady=6)
        
        self.timer_label = tk.Label(
            timer_display,
            text="--:--",
            font=("Segoe UI", 12, "bold"),
            bg='#f8f9fa',
            fg=self.colors['accent']
        )
        self.timer_label.pack(side=tk.RIGHT, padx=8, pady=6)
        
        # Auto-rotate toggle
        self.auto_rotate_var = tk.BooleanVar(value=False)
        ttk.Checkbutton(
            rotation_frame,
            text="Enable Auto-Rotate",
            variable=self.auto_rotate_var,
            command=self.toggle_auto_rotate
        ).pack(anchor=tk.W, pady=(0, 6))
        
        # Interval setting
        interval_frame = tk.Frame(rotation_frame, bg=self.colors['sidebar'])
        interval_frame.pack(fill=tk.X)
        
        tk.Label(
            interval_frame,
            text="Interval:",
            font=("Segoe UI", 8),
            bg=self.colors['sidebar']
        ).pack(side=tk.LEFT, padx=(0, 5))
        
        self.interval_entry = tk.Entry(
            interval_frame,
            font=("Segoe UI", 8),
            width=6,
            relief=tk.SOLID,
            borderwidth=1
        )
        self.interval_entry.insert(0, "60")
        self.interval_entry.pack(side=tk.LEFT, padx=(0, 5))
        
        tk.Label(
            interval_frame,
            text="min",
            font=("Segoe UI", 8),
            bg=self.colors['sidebar']
        ).pack(side=tk.LEFT, padx=(0, 5))
        
        tk.Button(
            interval_frame,
            text="Apply",
            command=self.apply_interval,
            bg=self.colors['accent'],
            fg='white',
            font=("Segoe UI", 8, "bold"),
            relief=tk.FLAT,
            cursor="hand2",
            padx=8,
            pady=3
        ).pack(side=tk.LEFT)
        
        # Current Wallpaper section
        self.create_section_header(sidebar_content, "‚ú® Current")
        
        current_frame = tk.Frame(sidebar_content, bg=self.colors['sidebar'])
        current_frame.pack(fill=tk.X, padx=20, pady=(0, 10))
        
        self.current_text = tk.Text(
            current_frame,
            height=3,
            font=("Segoe UI", 8),
            relief=tk.SOLID,
            borderwidth=1,
            bg='#f8f9fa',
            wrap=tk.WORD,
            padx=6,
            pady=6
        )
        self.current_text.pack(fill=tk.X)
        
        # Favorites section
        self.create_section_header(sidebar_content, "‚≠ê Favorites")
        
        # Favorites container
        self.favorites_container = tk.Frame(sidebar_content, bg=self.colors['sidebar'])
        self.favorites_container.pack(fill=tk.X, padx=20, pady=(0, 10))
        
        # History section
        self.create_section_header(sidebar_content, "üïê History")
        
        history_header = tk.Frame(sidebar_content, bg=self.colors['sidebar'])
        history_header.pack(fill=tk.X, padx=20, pady=(0, 6))
        
        tk.Button(
            history_header,
            text="Clear All",
            command=self.clear_history,
            bg='#dc3545',
            fg='white',
            font=("Segoe UI", 8, "bold"),
            relief=tk.FLAT,
            cursor="hand2",
            padx=8,
            pady=3
        ).pack(side=tk.RIGHT)
        
        # History thumbnails
        self.history_container = tk.Frame(sidebar_content, bg=self.colors['sidebar'])
        self.history_container.pack(fill=tk.X, padx=20, pady=(0, 10))
        
        # === LEFT SIDE: PREVIEW AREA ===
        preview_container = tk.Frame(content, bg=self.colors['preview_bg'])
        preview_container.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=(5, 0), pady=5)
        
        # Preview header
        preview_header = tk.Frame(preview_container, bg=self.colors['preview_bg'])
        preview_header.pack(fill=tk.X, padx=15, pady=(10, 8))
        
        tk.Label(
            preview_header,
            text="Preview",
            font=("Segoe UI", 12, "bold"),
            bg=self.colors['preview_bg'],
            fg='white'
        ).pack(side=tk.LEFT)
        
        self.preview_size_label = tk.Label(
            preview_header,
            text="",
            font=("Segoe UI", 9),
            bg=self.colors['preview_bg'],
            fg='#999999'
        )
        self.preview_size_label.pack(side=tk.RIGHT)
        
        # Canvas for image
        canvas_container = tk.Frame(preview_container, bg=self.colors['preview_bg'])
        canvas_container.pack(fill=tk.BOTH, expand=True, padx=15, pady=(0, 15))
        
        self.preview_canvas = tk.Canvas(
            canvas_container,
            bg='#2a2a2a',
            highlightthickness=0
        )
        self.preview_canvas.pack(fill=tk.BOTH, expand=True)
        
        # Placeholder text
        self.placeholder_id = self.preview_canvas.create_text(
            400, 300,
            text="üñºÔ∏è\n\nLoading wallpaper...",
            font=("Segoe UI", 14),
            fill='#666666',
            justify=tk.CENTER
        )
    
    def create_section_header(self, parent, text):
        """Create a section header in sidebar."""
        frame = tk.Frame(parent, bg=self.colors['sidebar'])
        frame.pack(fill=tk.X, padx=20, pady=(6, 6))
        
        tk.Label(
            frame,
            text=text,
            font=("Segoe UI", 9, "bold"),
            bg=self.colors['sidebar'],
            fg=self.colors['text']
        ).pack(side=tk.LEFT)
        
        # Separator line
        sep_frame = tk.Frame(parent, bg=self.colors['sidebar'])
        sep_frame.pack(fill=tk.X, padx=20, pady=(0, 8))
        tk.Frame(sep_frame, bg=self.colors['border'], height=1).pack(fill=tk.X)
    
    def load_history(self):
        """Load wallpaper history from JSON file."""
        if self.history_file.exists():
            try:
                with open(self.history_file, 'r') as f:
                    return json.load(f)
            except Exception as e:
                print(f"Error loading history: {e}")
                return []
        return []
    
    def save_history(self):
        """Save wallpaper history to JSON file."""
        try:
            with open(self.history_file, 'w') as f:
                json.dump(self.history, f, indent=2)
        except Exception as e:
            print(f"Error saving history: {e}")
    
    def update_status(self, message, color='#28a745'):
        """Update the status bar."""
        self.status_label.config(text=f"‚óè {message}", fg=color)
        self.root.update_idletasks()
    
    def fetch_from_url(self):
        """Fetch image from URL with progress indicator."""
        url = self.url_entry.get().strip()
        
        if not url:
            messagebox.showwarning("Input Required", "Please enter an image URL")
            return
        
        # Validate URL format
        try:
            result = urlparse(url)
            if not all([result.scheme, result.netloc]):
                raise ValueError("Invalid URL format")
        except Exception:
            messagebox.showerror("Invalid URL", "Please enter a valid URL")
            return
        
        # Show progress
        self.progress.pack(pady=10)
        self.progress.start()
        self.update_status("Downloading...", '#007bff')
        self.fetch_btn.config(state=tk.DISABLED)
        
        # Download in thread to keep GUI responsive
        def download():
            try:
                response = requests.get(url, timeout=30, stream=True)
                response.raise_for_status()
                
                # Check if it's an image
                content_type = response.headers.get('content-type', '')
                if 'image' not in content_type.lower():
                    raise ValueError("URL does not point to an image")
                
                # Save to wallpapers directory
                filename = f"wallpaper_{datetime.now().strftime('%Y%m%d_%H%M%S')}.jpg"
                temp_path = self.wallpapers_dir / filename
                
                with open(temp_path, 'wb') as f:
                    for chunk in response.iter_content(chunk_size=8192):
                        f.write(chunk)
                
                # Update UI in main thread
                self.root.after(0, lambda: self.on_download_complete(str(temp_path), url))
                
            except requests.exceptions.RequestException as e:
                self.root.after(0, lambda: self.on_download_error(f"Download failed: {str(e)}"))
            except Exception as e:
                self.root.after(0, lambda: self.on_download_error(f"Error: {str(e)}"))
        
        threading.Thread(target=download, daemon=True).start()
    
    def on_download_complete(self, image_path, source_url):
        """Handle successful download."""
        self.progress.stop()
        self.progress.pack_forget()
        self.fetch_btn.config(state=tk.NORMAL)
        self.preview_image_path = image_path
        self.display_preview(image_path, f"URL: {source_url}")
        self.update_status("Downloaded successfully", '#28a745')
    
    def on_download_error(self, error_message):
        """Handle download error."""
        self.progress.stop()
        self.progress.pack_forget()
        self.fetch_btn.config(state=tk.NORMAL)
        messagebox.showerror("Download Error", error_message)
        self.update_status("Download failed", '#dc3545')
    
    def browse_file(self):
        """Browse for local image file."""
        filetypes = (
            ("Image files", "*.jpg *.jpeg *.png *.bmp *.gif"),
            ("All files", "*.*")
        )
        
        filename = filedialog.askopenfilename(
            title="Select Wallpaper Image",
            filetypes=filetypes
        )
        
        if filename:
            self.file_entry.delete(0, tk.END)
            self.file_entry.insert(0, filename)
            self.preview_image_path = filename
            self.display_preview(filename, f"Local: {os.path.basename(filename)}")
    
    def display_preview(self, image_path, info_text):
        """Display image preview in canvas."""
        try:
            # Open and resize image
            img = Image.open(image_path)
            original_size = f"{img.width} √ó {img.height}"
            
            # Calculate size to fit in canvas (maintain aspect ratio)
            canvas_width = self.preview_canvas.winfo_width()
            canvas_height = self.preview_canvas.winfo_height()
            
            # Use default size if canvas not yet rendered
            if canvas_width <= 1:
                canvas_width = 800
            if canvas_height <= 1:
                canvas_height = 700
            
            # Remove placeholder
            if self.placeholder_id:
                self.preview_canvas.delete(self.placeholder_id)
                self.placeholder_id = None
            
            img.thumbnail((canvas_width - 40, canvas_height - 40), Image.Resampling.LANCZOS)
            
            # Convert to PhotoImage
            self.preview_photo = ImageTk.PhotoImage(img)
            
            # Clear canvas and display image
            self.preview_canvas.delete("all")
            self.preview_canvas.create_image(
                canvas_width // 2,
                canvas_height // 2,
                image=self.preview_photo,
                anchor=tk.CENTER
            )
            
            # Update info
            self.preview_info_text.config(state=tk.NORMAL)
            self.preview_info_text.delete(1.0, tk.END)
            self.preview_info_text.insert(1.0, f"{info_text}\nResolution: {original_size} px")
            self.preview_info_text.config(state=tk.DISABLED)
            
            self.preview_size_label.config(text=original_size)
            
            # Enable set and favorite buttons
            self.set_button.config(state=tk.NORMAL)
            self.favorite_button.config(state=tk.NORMAL)
            self.update_status("Preview loaded", '#28a745')
            
        except Exception as e:
            messagebox.showerror("Preview Error", f"Could not load image: {str(e)}")
            self.update_status("Preview failed", '#dc3545')
    
    def set_wallpaper(self):
        """Set the previewed image as wallpaper."""
        if not self.preview_image_path:
            messagebox.showwarning("No Image", "Please select an image first")
            return
        
        try:
            # Convert to absolute path
            image_path = os.path.abspath(self.preview_image_path)
            
            self.update_status("Setting wallpaper...", '#007bff')
            
            # Set wallpaper based on platform
            success = self.set_wallpaper_platform(image_path)
            
            if success:
                # Add to history
                self.add_to_history(image_path)
                
                # Refresh display
                self.refresh_display()
                
                messagebox.showinfo("Success", "Wallpaper set successfully!")
                self.update_status("Wallpaper applied", '#28a745')
            else:
                messagebox.showerror("Error", "Failed to set wallpaper")
                self.update_status("Failed", '#dc3545')
                
        except Exception as e:
            messagebox.showerror("Error", f"Failed to set wallpaper: {str(e)}")
            self.update_status("Error occurred", '#dc3545')
    
    def set_wallpaper_platform(self, image_path):
        """Set wallpaper based on platform."""
        system = platform.system()
        
        try:
            if system == "Windows":
                import ctypes
                ctypes.windll.user32.SystemParametersInfoW(20, 0, image_path, 3)
                return True
                
            elif system == "Darwin":  # macOS
                script = f'''
                tell application "System Events"
                    tell every desktop
                        set picture to "{image_path}"
                    end tell
                end tell
                '''
                subprocess.run(["osascript", "-e", script], check=True)
                return True
                
            elif system == "Linux":
                desktop = os.environ.get('DESKTOP_SESSION', '').lower()
                
                try:
                    subprocess.run([
                        "gsettings", "set",
                        "org.gnome.desktop.background", "picture-uri",
                        f"file://{image_path}"
                    ], check=True, capture_output=True)
                    subprocess.run([
                        "gsettings", "set",
                        "org.gnome.desktop.background", "picture-uri-dark",
                        f"file://{image_path}"
                    ], check=True, capture_output=True)
                    return True
                except (subprocess.CalledProcessError, FileNotFoundError):
                    pass
                
                if 'gnome' in desktop:
                    subprocess.run([
                        "gsettings", "set",
                        "org.gnome.desktop.background", "picture-uri",
                        f"file://{image_path}"
                    ], check=True)
                    return True
                elif 'kde' in desktop or 'plasma' in desktop:
                    script = f'''
                    qdbus org.kde.plasmashell /PlasmaShell org.kde.PlasmaShell.evaluateScript '
                        var allDesktops = desktops();
                        for (i=0;i<allDesktops.length;i++) {{
                            d = allDesktops[i];
                            d.wallpaperPlugin = "org.kde.image";
                            d.currentConfigGroup = Array("Wallpaper", "org.kde.image", "General");
                            d.writeConfig("Image", "file://{image_path}");
                        }}
                    '
                    '''
                    subprocess.run(script, shell=True, check=True)
                    return True
                elif 'xfce' in desktop:
                    subprocess.run([
                        "xfconf-query", "-c", "xfce4-desktop",
                        "-p", "/backdrop/screen0/monitor0/workspace0/last-image",
                        "-s", image_path
                    ], check=True)
                    return True
                else:
                    subprocess.run(["feh", "--bg-scale", image_path], check=True)
                    return True
            
            return False
            
        except Exception as e:
            print(f"Error setting wallpaper: {e}")
            return False
    
    def add_to_history(self, image_path):
        """Add image to history."""
        entry = {
            "path": image_path,
            "timestamp": datetime.now().isoformat(),
            "filename": os.path.basename(image_path)
        }
        
        self.history = [h for h in self.history if h.get("path") != image_path]
        self.history.insert(0, entry)
        self.history = self.history[:8]
        self.save_history()
    
    def refresh_display(self):
        """Refresh the history and current wallpaper display."""
        self.history = self.load_history()
        self.favorites = self.load_favorites()
        self.display_history()
        self.display_favorites()
        self.display_current_wallpaper()
    
    def display_history(self):
        """Display history thumbnails."""
        for widget in self.history_container.winfo_children():
            widget.destroy()
        
        if not self.history:
            tk.Label(
                self.history_container,
                text="No history",
                font=("Segoe UI", 9),
                bg=self.colors['sidebar'],
                fg='gray'
            ).pack(pady=20)
            return
        
        for idx, item in enumerate(self.history):
            self.create_history_thumbnail(item, idx)
    
    def create_history_thumbnail(self, item, index):
        """Create a thumbnail widget for a history item."""
        frame = tk.Frame(
            self.history_container,
            bg='white',
            relief=tk.SOLID,
            borderwidth=1
        )
        frame.pack(fill=tk.X, pady=3)
        
        try:
            # Load thumbnail
            img = Image.open(item["path"])
            img.thumbnail((70, 45), Image.Resampling.LANCZOS)
            photo = ImageTk.PhotoImage(img)
            
            inner = tk.Frame(frame, bg='white')
            inner.pack(fill=tk.X, padx=5, pady=5)
            
            label = tk.Label(inner, image=photo, bg='white', cursor="hand2")
            label.image = photo
            label.pack(side=tk.LEFT, padx=(0, 8))
            
            info_frame = tk.Frame(inner, bg='white')
            info_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
            
            tk.Label(
                info_frame,
                text=item['filename'][:22],
                font=("Segoe UI", 8, "bold"),
                bg='white',
                fg=self.colors['text'],
                anchor=tk.W
            ).pack(fill=tk.X)
            
            tk.Label(
                info_frame,
                text=item['timestamp'][:10],
                font=("Segoe UI", 7),
                bg='white',
                fg='gray',
                anchor=tk.W
            ).pack(fill=tk.X)
            
            label.bind("<Button-1>", lambda e, path=item["path"]: self.set_from_history(path))
            
            def on_enter(e):
                frame.config(bg=self.colors['accent'])
            def on_leave(e):
                frame.config(bg='white')
            
            frame.bind("<Enter>", on_enter)
            frame.bind("<Leave>", on_leave)
            label.bind("<Enter>", on_enter)
            
        except Exception:
            tk.Label(
                frame,
                text=f"Error: {item['filename'][:20]}",
                font=("Segoe UI", 8),
                bg='white',
                fg='red'
            ).pack(padx=5, pady=5)
    
    def set_from_history(self, image_path):
        """Set wallpaper from history."""
        if os.path.exists(image_path):
            self.preview_image_path = image_path
            self.display_preview(image_path, f"History: {os.path.basename(image_path)}")
            self.set_wallpaper()
        else:
            messagebox.showerror("Error", f"Image file not found:\n{image_path}")
    
    def display_current_wallpaper(self):
        """Display current wallpaper info."""
        self.current_text.config(state=tk.NORMAL)
        self.current_text.delete(1.0, tk.END)
        
        if self.history:
            current = self.history[0]
            info = f"üìÅ {current['filename']}\n\n"
            info += f"üïí {current['timestamp'][:19].replace('T', ' ')}\n\n"
            info += f"üìç {current['path']}"
            self.current_text.insert(1.0, info)
        else:
            self.current_text.insert(1.0, "No wallpaper set yet")
        
        self.current_text.config(state=tk.DISABLED)
    
    def clear_history(self):
        """Clear wallpaper history."""
        if not self.history:
            return
            
        if messagebox.askyesno("Clear History", "Clear all history entries?"):
            self.history = []
            self.save_history()
            self.refresh_display()
            self.update_status("History cleared", '#28a745')
    
    def auto_fetch_and_set(self):
        """Auto fetch new wallpaper and immediately set it (sync)."""
        self.update_status("Auto-fetching wallpaper...", '#007bff')
        self.auto_fetch_btn.config(state=tk.DISABLED)
        
        def auto_fetch_task():
            try:
                # Fetch from current URL
                url = self.url_entry.get().strip() or "https://picsum.photos/1920/1080"
                
                response = requests.get(url, timeout=30, stream=True)
                response.raise_for_status()
                
                # Save image
                filename = f"wallpaper_{datetime.now().strftime('%Y%m%d_%H%M%S')}.jpg"
                temp_path = self.wallpapers_dir / filename
                
                with open(temp_path, 'wb') as f:
                    for chunk in response.iter_content(chunk_size=8192):
                        f.write(chunk)
                
                # Set as wallpaper immediately
                image_path = str(temp_path)
                success = self.set_wallpaper_platform(image_path)
                
                if success:
                    self.add_to_history(image_path)
                    self.root.after(0, lambda: self.on_auto_fetch_success(image_path))
                else:
                    self.root.after(0, lambda: self.on_auto_fetch_error("Failed to set wallpaper"))
                    
            except Exception as e:
                self.root.after(0, lambda: self.on_auto_fetch_error(str(e)))
        
        threading.Thread(target=auto_fetch_task, daemon=True).start()
    
    def on_auto_fetch_success(self, image_path):
        """Handle successful auto-fetch."""
        self.auto_fetch_btn.config(state=tk.NORMAL)
        self.refresh_display()
        self.update_status(f"Auto-fetched: {os.path.basename(image_path)}", '#28a745')
        self.reset_timer()  # Reset timer after manual fetch
    
    def on_auto_fetch_error(self, error):
        """Handle auto-fetch error."""
        self.auto_fetch_btn.config(state=tk.NORMAL)
        self.update_status("Auto-fetch failed", '#dc3545')
        messagebox.showerror("Auto-Fetch Error", f"Failed to fetch wallpaper:\n{error}")
    
    def toggle_auto_rotate(self):
        """Toggle auto-rotation on/off."""
        self.auto_rotate_enabled = self.auto_rotate_var.get()
        
        if self.auto_rotate_enabled:
            self.start_auto_rotate()
        else:
            self.stop_auto_rotate()
    
    def apply_interval(self):
        """Apply new rotation interval."""
        try:
            interval = int(self.interval_entry.get())
            if interval < 1:
                raise ValueError("Interval must be at least 1 minute")
            
            self.rotation_interval_minutes = interval
            self.update_status(f"Interval set to {interval} min", '#28a745')
            
            # Reset timer if auto-rotate is active
            if self.auto_rotate_enabled:
                self.reset_timer()
                
        except ValueError as e:
            messagebox.showerror("Invalid Input", "Please enter a valid number (minimum 1 minute)")
    
    def start_auto_rotate(self):
        """Start auto-rotation with timer."""
        self.update_status("Auto-rotate enabled", '#28a745')
        self.reset_timer()
    
    def stop_auto_rotate(self):
        """Stop auto-rotation."""
        self.stop_timer_flag = True
        self.timer_label.config(text="--:--")
        self.update_status("Auto-rotate disabled", '#6c757d')
    
    def reset_timer(self):
        """Reset the countdown timer."""
        if not self.auto_rotate_enabled:
            return
        
        # Stop existing timer
        self.stop_timer_flag = True
        if self.timer_thread and self.timer_thread.is_alive():
            self.timer_thread.join(timeout=1.0)
        
        # Start new timer
        self.time_remaining_seconds = self.rotation_interval_minutes * 60
        self.stop_timer_flag = False
        self.timer_thread = threading.Thread(target=self.timer_worker, daemon=True)
        self.timer_thread.start()
    
    def timer_worker(self):
        """Background worker for countdown timer."""
        while self.time_remaining_seconds > 0 and not self.stop_timer_flag:
            # Update timer display
            mins, secs = divmod(self.time_remaining_seconds, 60)
            self.root.after(0, lambda m=mins, s=secs: self.timer_label.config(text=f"{m:02d}:{s:02d}"))
            
            time.sleep(1)
            self.time_remaining_seconds -= 1
        
        # Timer expired - trigger auto-fetch
        if not self.stop_timer_flag and self.auto_rotate_enabled:
            self.root.after(0, self.auto_rotate_fetch)
    
    def auto_rotate_fetch(self):
        """Fetch and set new wallpaper when timer expires."""
        self.auto_fetch_and_set()
    
    def fetch_random_wallpaper(self):
        """Fetch a random wallpaper with current resolution."""
        resolution = self.resolution_var.get()
        width, height = resolution.split('x')
        url = f"https://picsum.photos/{width}/{height}"
        self.url_entry.delete(0, tk.END)
        self.url_entry.insert(0, url)
        self.fetch_from_url()
    
    def update_url_with_resolution(self, event=None):
        """Update URL when resolution changes."""
        current_url = self.url_entry.get().strip()
        if "picsum.photos" in current_url:
            resolution = self.resolution_var.get()
            width, height = resolution.split('x')
            new_url = f"https://picsum.photos/{width}/{height}"
            self.url_entry.delete(0, tk.END)
            self.url_entry.insert(0, new_url)
    
    def open_wallpapers_folder(self):
        """Open wallpapers directory in file manager."""
        try:
            system = platform.system()
            if system == "Windows":
                os.startfile(self.wallpapers_dir)
            elif system == "Darwin":  # macOS
                subprocess.run(["open", str(self.wallpapers_dir)])
            else:  # Linux
                subprocess.run(["xdg-open", str(self.wallpapers_dir)])
            self.update_status("Opened wallpapers folder", '#28a745')
        except Exception as e:
            messagebox.showerror("Error", f"Could not open folder: {str(e)}")
    
    def load_favorites(self):
        """Load favorites from JSON file."""
        favorites_file = self.data_dir / "favorites.json"
        if favorites_file.exists():
            try:
                with open(favorites_file, 'r') as f:
                    return json.load(f)
            except Exception as e:
                print(f"Error loading favorites: {e}")
                return []
        return []
    
    def save_favorites(self):
        """Save favorites to JSON file."""
        try:
            favorites_file = self.data_dir / "favorites.json"
            with open(favorites_file, 'w') as f:
                json.dump(self.favorites, f, indent=2)
        except Exception as e:
            print(f"Error saving favorites: {e}")
    
    def add_to_favorites(self):
        """Add current preview to favorites."""
        if not self.preview_image_path:
            messagebox.showwarning("No Image", "Please select an image first")
            return
        
        # Check if already in favorites
        for fav in self.favorites:
            if fav.get("path") == self.preview_image_path:
                messagebox.showinfo("Already Added", "This wallpaper is already in favorites")
                return
        
        entry = {
            "path": self.preview_image_path,
            "timestamp": datetime.now().isoformat(),
            "filename": os.path.basename(self.preview_image_path)
        }
        
        self.favorites.insert(0, entry)
        self.favorites = self.favorites[:10]  # Keep max 10 favorites
        self.save_favorites()
        self.display_favorites()
        
        self.update_status("Added to favorites", '#28a745')
        messagebox.showinfo("Success", "Wallpaper added to favorites!")
    
    def display_favorites(self):
        """Display favorite wallpapers."""
        for widget in self.favorites_container.winfo_children():
            widget.destroy()
        
        if not self.favorites:
            tk.Label(
                self.favorites_container,
                text="No favorites yet",
                font=("Segoe UI", 9),
                bg=self.colors['sidebar'],
                fg='gray'
            ).pack(pady=10)
            return
        
        for idx, item in enumerate(self.favorites):
            self.create_favorite_thumbnail(item, idx)
    
    def create_favorite_thumbnail(self, item, index):
        """Create a thumbnail widget for a favorite item."""
        frame = tk.Frame(
            self.favorites_container,
            bg='#fff3cd',
            relief=tk.SOLID,
            borderwidth=1
        )
        frame.pack(fill=tk.X, pady=3)
        
        try:
            # Load thumbnail
            img = Image.open(item["path"])
            img.thumbnail((55, 35), Image.Resampling.LANCZOS)
            photo = ImageTk.PhotoImage(img)
            
            inner = tk.Frame(frame, bg='#fff3cd')
            inner.pack(fill=tk.X, padx=5, pady=5)
            
            label = tk.Label(inner, image=photo, bg='#fff3cd', cursor="hand2")
            label.image = photo
            label.pack(side=tk.LEFT, padx=(0, 8))
            
            info_frame = tk.Frame(inner, bg='#fff3cd')
            info_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
            
            tk.Label(
                info_frame,
                text=item['filename'][:20],
                font=("Segoe UI", 8, "bold"),
                bg='#fff3cd',
                fg='#856404',
                anchor=tk.W
            ).pack(fill=tk.X)
            
            # Remove button
            remove_btn = tk.Label(
                inner,
                text="‚úñ",
                font=("Segoe UI", 10, "bold"),
                bg='#fff3cd',
                fg='#dc3545',
                cursor="hand2"
            )
            remove_btn.pack(side=tk.RIGHT)
            remove_btn.bind("<Button-1>", lambda e, path=item["path"]: self.remove_from_favorites(path))
            
            label.bind("<Button-1>", lambda e, path=item["path"]: self.set_from_favorites(path))
            
            def on_enter(e):
                frame.config(bg='#ffc107')
                inner.config(bg='#ffc107')
                label.config(bg='#ffc107')
                info_frame.config(bg='#ffc107')
                remove_btn.config(bg='#ffc107')
            def on_leave(e):
                frame.config(bg='#fff3cd')
                inner.config(bg='#fff3cd')
                label.config(bg='#fff3cd')
                info_frame.config(bg='#fff3cd')
                remove_btn.config(bg='#fff3cd')
            
            frame.bind("<Enter>", on_enter)
            frame.bind("<Leave>", on_leave)
            label.bind("<Enter>", on_enter)
            
        except Exception:
            tk.Label(
                frame,
                text=f"Error: {item['filename'][:15]}",
                font=("Segoe UI", 7),
                bg='#fff3cd',
                fg='red'
            ).pack(padx=5, pady=5)
    
    def set_from_favorites(self, image_path):
        """Set wallpaper from favorites."""
        if os.path.exists(image_path):
            self.preview_image_path = image_path
            self.display_preview(image_path, f"Favorite: {os.path.basename(image_path)}")
            self.set_wallpaper()
        else:
            messagebox.showerror("Error", f"Image file not found:\n{image_path}")
            self.remove_from_favorites(image_path)
    
    def remove_from_favorites(self, image_path):
        """Remove image from favorites."""
        self.favorites = [f for f in self.favorites if f.get("path") != image_path]
        self.save_favorites()
        self.display_favorites()
        self.update_status("Removed from favorites", '#6c757d')
    
    def auto_fetch_on_launch(self):
        """Auto-fetch a wallpaper when the GUI launches."""
        self.update_status("Fetching wallpaper...", '#007bff')
        
        def fetch_task():
            try:
                url = self.url_entry.get().strip() or "https://picsum.photos/1920/1080"
                response = requests.get(url, timeout=30, stream=True)
                response.raise_for_status()
                
                filename = f"wallpaper_{datetime.now().strftime('%Y%m%d_%H%M%S')}.jpg"
                temp_path = self.wallpapers_dir / filename
                
                with open(temp_path, 'wb') as f:
                    for chunk in response.iter_content(chunk_size=8192):
                        f.write(chunk)
                
                # Display preview
                self.root.after(0, lambda: self.on_launch_fetch_success(str(temp_path)))
                
            except Exception as e:
                self.root.after(0, lambda: self.update_status("Ready", '#28a745'))
        
        threading.Thread(target=fetch_task, daemon=True).start()
    
    def on_launch_fetch_success(self, image_path):
        """Handle successful launch fetch."""
        self.preview_image_path = image_path
        self.display_preview(image_path, f"Picsum: {os.path.basename(image_path)}")
        self.update_status("Downloaded successfully", '#28a745')


def main():
    """Launch the GUI application."""
    root = tk.Tk()
    app = WallpaperManagerGUI(root)
    root.mainloop()


if __name__ == "__main__":
    main()